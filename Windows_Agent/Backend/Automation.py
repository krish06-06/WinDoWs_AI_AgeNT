import sys
import os
import subprocess
import keyboard
import asyncio
import time
import requests
from webbrowser import open as webopen
from pywhatkit import search, playonyt
from AppOpener import close, open as appopen
from dotenv import dotenv_values
from rich import print

# Root Directory Setup
ROOT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
if ROOT_DIR not in sys.path:
    sys.path.insert(0, ROOT_DIR)

# Load environment variables
env_vars = dotenv_values(".env")
Username = env_vars.get("Username", "User")


Professional_responses = [
    f"Task completed successfully, {Username}.",
    f"I've handled that for you. Is there anything else?"
]

def Openapp(app, text_to_write=""):
    """
    Opens applications. Strictly uses the provided name.
    Includes a special automation for writing notes in Notepad.
    """
    app = app.lower().strip()

    # Special logic for Notepad automation (Content Writing)
    if "notepad" in app:
        try:
            subprocess.Popen("notepad.exe")
            time.sleep(1.5) # Wait for app to focus
            if text_to_write:
                keyboard.write(text_to_write)
                return True
        except Exception as e:
            print(f"Error opening Notepad: {e}")
            return False

    # Strict App Opening
    try:
        # match_closest=False prevents it from closing/opening the wrong thing
        appopen(app, match_closest=False, throw_error=True)
        return True
    except:
        # If app fails, check if it's a known common website
        known_websites = {
            "youtube": "https://www.youtube.com",
            "gmail": "https://mail.google.com",
            "github": "https://www.github.com"
        }
        if app in known_websites:
            webopen(known_websites[app])
            return True
        
    print(f"[red]Could not find application: {app}[/red]")
    return False

def closeapp(app):
    """Strictly closes the named application."""
    try:
        # match_closest=False as same as open app 
        close(app, match_closest=False, throw_error=True)
        return True
    except:
        return False

def Googlesearch(topic):
    """Opens a browser and searches Google."""
    search(topic)
    return True

async def translate_and_execute(commands: list[str]):
    """Executes the list of commands generated by the DMM."""
    funcs = []

    for command in commands:
        command = command.lower().strip()
        
        if command.startswith("open "):
            name = command.removeprefix("open ")
            
            if "notepad" in name and "(" in name:
                content = name.split("(")[1].replace(")", "")
                fun = asyncio.to_thread(Openapp, "notepad", content)
            else:
                fun = asyncio.to_thread(Openapp, name)
            funcs.append(fun)

        elif command.startswith("close "):
            fun = asyncio.to_thread(closeapp, command.removeprefix("close "))
            funcs.append(fun)

        elif command.startswith("play "):
            fun = asyncio.to_thread(playonyt, command.removeprefix("play "))
            funcs.append(fun)

        elif command.startswith("google search "):
            fun = asyncio.to_thread(Googlesearch, command.removeprefix("google search "))
            funcs.append(fun)

    if funcs:
        results = await asyncio.gather(*funcs)
        for result in results:
            yield result

async def Automation(commands: list[str]):
    async for result in translate_and_execute(commands):
        pass
    return True

if __name__ == "__main__":
    # Simple CLI
    print(f"Tiny Assistant Automation Module Loaded")
    while True:
        print("\n1. Test Open | 2. Test Close | 3. Test Search | 4. Exit")
        choice = input("Select: ")
        
        if choice == '1':
            q = input("App to open: ")
            asyncio.run(Automation([f"open {q}"]))
        elif choice == '2':
            q = input("App to close: ")
            asyncio.run(Automation([f"close {q}"]))
        elif choice == '3':
            q = input("Topic to search: ")
            asyncio.run(Automation([f"google search {q}"]))
        elif choice == '4':
            break